### 8.33 New sync DB 

#### A. Транспорт и безопасность
- [x] Сквозное шифрование (X25519 + HKDF + NaCl SecretBox), направленные ключи, SAS, TOFU-хранилище (атомично, с fsync).
- [x] Чанковая передача с ACK, итоговый SHA-256, атомарная запись на приёмнике (`.tmp` → `os.replace`).
- [x] mDNS: объявление/поиск, корректный unreg при стопе, подбор реального IPv4.
- [+] «Проверить соединение» с таймаутом/ретраями и подсказками (порт, фаервол). *(базовый есть, доработать UX/тексты ошибок)*
- [x] Троттлинг скорости (лимит КБ/c) — опция в GUI.
- [x] Перезапуск приёмника при сбое mDNS/сокета (авто-рестарт).
- [x] Резюмируемая отправка (resume from offset): сверка размера/хеша снапшота и докачка недостающих чанков.
- [x] Доп. контроль целостности на каждый чанк (CRC32/sha256) + перезапрос конкретных чанков.
- [x] Опциональное сжатие (gzip) на лету для SQLite-снапшота.

#### B. GUI/UX
- [x] Вкладки: Send / Receive / Merge / Logs; крупный SAS в обеих; индикатор статуса сервера (красный/зелёный).
- [x] История адресов/портов (~/.player_db_gui.json); автоскролл логов; метки времени.
- [x] Тихие логи (агрегаты), сводка по таблицам всегда; компактный вывод FK-violations (топ-10).
- [+] mDNS-список приёмников в выпадающем списке (есть скан; добить автo-обновление и «Очистить/Обновить»).
- [x] Кнопки «Сохранить лог» и «Очистить лог».
- [x] Кнопка «Сбросить доверие (TOFU)» для выбранного хоста.
- [x] Настройки: лимит скорости, размер чанка, опция сжатия, флаги merge (см. ниже) — сохранять в конфиг.
- [x] Вывод всех сообщений в логи
- [x] Чекбокс compress gzip при отправке
- [x] Чекбокс VACUUM при отправке

#### C. Merge (логика и целостность)
- [x] Мёрдж по «естественным» ключам: `episodes.uuid`, `torrents.hash`; **никогда** не переписывать локальные `episode_id/torrent_id`.
- [x] `history`: резолв `episode_id` через `uuid`, `torrent_id` через `hash`; пропуск сирот с логом.
- [x] `schedule/production_studios/posters/franchise_releases`: `ensure_title_in_dst(...)`; щадящий пропуск сирот; `posters` — дедуп по `(title_id, hash_value)`, insert без `poster_id`.
- [x] Умный мёрдж `franchise_releases` по смысловому ключу, без переноса суррогатного `id`.
- [x] Итоговый отчёт: число пропущенных по каждой таблице + экспорт CSV «сироты/дубликаты».
- [x] Чекбоксы в GUI Merge: 
      
      1. «Пропускать постеры без hash»
      2. «Нормализовать дни недели (0..6→1..7)» *(дефолт: выкл, на случай неконсистентных источников)*
      3. «Skip orphans» (поведение по умолчанию уже щадящее — оставить как опцию).
- [x] `PRAGMA optimize`/`VACUUM` после большого мержа (по чекбоксу).

#### D. Сборка/релиз
- [x] Новый entry-point `db_sync_gui.py`; старые `sync/merge_utility` исключить из spec/бандла.
- [+] PyInstaller spec: `zeroconf`, `nacl` в hiddenimports; иконка/версия/имя EXE.
- [x] Post-install подсказка про Windows Firewall (вход на выбранный порт).

### 8.34 New sync DB «Через интернет» без релея — два пути

#### Вариант 1 — **без релея, без «магии»** (самый простой и надёжный)
#### Этап 1 — Internet (TCP + STUN/UPnP)
- [x] использовать текущий TCP протокол
- [x] Режим «Internet» в GUI (переключатель Receive)
- [x]  STUN-детектор внешнего IP (pystun3), отображение адреса и порта
- [x] UPnP / NAT-PMP автопроброс (miniupnpc); результат в логах
- [x] Кнопка «Проверить доступность» (таймаут, диагностика)
- [x] Абстрактный TransportBase
- [x] Реализация TCPTransport
- [ ] Ограничение источников по IP / rate-limit

#### Вариант 2 — **NAT traversal без ручного проброса** (без релея; STUN допустим)
#### Этап 2 — WebRTC (DataChannel)
- [x] WebRTCTransport — ядро (offer/answer, ICE, DataChannel) есть.
- [x] GUI: офлайн-сигналинг (Offer/Answer) есть.
- [x] Индикатор ICE есть (states в логах и label).
- [+] Логика fallback к TCP
- [x] GUI: Отобразить компактно в два столбца по смыслу, add scroll
- [x] Pretty Gui
- [x] Split in 2 version LAN and Inet
- [x] Fix transport for LAN version
- [x] Fix shutdown
- [ ] **Нет передачи БД поверх WebRTC** — ни на отправителе, ни на приёмнике.
#### 1. **Отправитель (WebRTCSenderTransport):**
   - вместо `send_bytes(b"hello from WebRTC sender")`:
   - открыть `db_path`;
   - читать по `chunk_size`;
   - слать через `self._core.send_bytes(...)`;
   - вызывать `self._on_progress(sent, total)`.

#### 2. **Приёмник (WebRTCReceiverCore + GUI):**
   - в `set_on_message` повесить обработчик, который:
   - создаёт файл в `incoming` (имя можно передать в первом сообщении — «хедер» с метаданными: имя, размер, флаг gzip и т.п.);
   - пишет прилетевшие байты в этот файл;
   - по мере записи обновляет прогресс в GUI;
   - в конце — закрывает файл и логирует «файл принят».

#### 3. **Мини-протокол поверх DataChannel:**
   - либо:
     - первое сообщение — JSON с метаданными (`{"name": "...", "size": ..., "gzip": true}`),
     - дальше — сырые чанки;
   - либо поверх WebRTC просто прогнать уже существующий TCP-протокол `DBSender`/`DBReceiver`, но тогда надо чуть больше аккуратности (фрейминг, размеры и т.п.).

- [ ] Добить мелкую косметику (например, текст заголовков/подсказок под каждый режим)
- [ ] Тест-кнопка «ICE connected?» с логом статусов
- [ ] Тестирование разных NAT/CGNAT сценариев
- [ ] expand offer/answer data. показывать свернутым по умолчанию
- [ ] формировать QR code for offer/answer