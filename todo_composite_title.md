Думаю у тебя уже очень хороший скелет задач, давай его чуть структурируем и добавим недостающее.

Твой список:

1. создать таблицу
2. добавить поля
3. добавить адаптер в котором указать какие данные откуда брать чтобы объеденить без дублей
4. добавить методы которые в бд извлекают данные
5. добавить в фабрике получение
6. добавить обработку при отображениии эпизодов
7. добавить форму где можно будет слинковать тайтлы

Я бы разложил это по блокам и добавил ещё пару важных пунктов.

---

## А. БД и модели

**1. Создать таблицу связей**

`composite_titles (composite_title_id, source_title_id, priority)` + индексы, foreign key, ON DELETE CASCADE и т.п.

**2. Добавить поля в `titles`**

* `is_composite: bool` (обязательно, not null, default False)
* при желании — `composite_label` или `display_title_source`/`main_source_id` и т.п.

**3. Миграция**

Отдельным пунктом (его не хватает в списке):

* alembic/скрипт миграции:

  * добавить столбец `is_composite`
  * создать таблицу `composite_titles`
  * проставить `is_composite = 0` для всех существующих.

---

## B. Доменная логика / репо

**4. Методы для работы с БД (репозитории)**

Это твой пункт 4, но я бы его явно разбил:

* `get_source_title_ids(composite_title_id) -> list[int]`
* `create_composite_title(base_meta, source_ids)`
* `update_composite_sources(composite_title_id, source_ids)`
* `delete_composite_title(composite_title_id)` (можно просто удалить title — остальное упадёт каскадом)
* helper: `is_composite(title_id) -> bool`

Плюс:

**5. Правила выбора метаданных**

Чего ещё нет в списке, но понадобится:

* откуда брать:

  * название,
  * постер,
  * описание,
  * год и т.п.

Нужно хотя бы в голове (а лучше в коде) зафиксировать стратегию:

* либо «берём из `Title` самого composite», а source только для эпизодов/стримов (мне это больше всего нравится),
* либо «берём из source с `priority = 0`», а в composite минимум полей.

---

## C. Адаптер / фабрика (то, что формирует view model)

**6. Адаптер объединения без дублей** — твой пункт 3

* Функция, которая на вход получает:

  * `Map[title_id -> список эпизодов/стримов]`,
  * на выход — **слитый список логических эпизодов**:

    * ключ группировки: (season, episode_number) или просто episode_number,
    * внутри — список `streams` по провайдерам.

**7. Методы извлечения данных для фабрики** — твой пункт 4

* уже с учётом того, что на вход фабрики теперь может прийти **несколько title_ids**:

  * получить все `Title` по списку айдишников,
  * получить все эпизоды по этим тайтлам,
  * получить стримы/host_for_player для каждого провайдера.

**8. Изменения в фабрике** — твой пункт 5

* В месте, где сейчас:
  `build_title_vm([title_id])`
  сделать:

  * если `!is_composite` → `[title_id]`,
  * если `is_composite` → развернуть в список source_ids и передать в фабрику.
* Фабрика:

  * вместо «один тайтл → список эпизодов» делает «несколько тайтлов → episodes_by_title → merged_episodes».

---

## D. Обработка в UI / плеере

**9. Обработка при отображении эпизодов** — твой пункт 6

* изменить структуру данных эпизода в view model:

Было (условно):

```json
{
  "episode": 1,
  "url": "...",
  "host": "...",
}
```

Стало:

```json
{
  "episode": 1,
  "title": "Episode 1",
  "streams": [
    {"provider": "anilibria", "url": "...", "host": "..."},
    {"provider": "shikimori", "url": "...", "host": "..."}
  ]
}
```

* добавить в UI выбор провайдера:

  * либо маленькое меню/кнопки,
  * либо выпадающий список.

И важное, чего нет в списке:

**10. Бэкенд/фронт-совместимость**

* убедиться, что:

  * если `streams` длиной 1 — UI ведёт себя как раньше,
  * старые тайтлы (несоставные) продолжают работать без изменений.

---

## E. UI для управления составными тайтлами

**11. Форма для линковки тайтлов** — твой пункт 7

* базовый минимум:

  * выбрать «основной» (composite) тайтл или создать новый,
  * добавить/удалить source-тайтлы,
  * сохранять priority.
* в идеале:

  * простая фильтрация/поиск по названию,
  * защита от глупостей:

    * нельзя сделать source = сам composite,
    * нельзя добавить один и тот же title дважды.

**12. Поведение в списках / поиске (важный пункт, которого нет)**

Нужно решить:

* В общем списке тайтлов показывать:

  * **и composite, и source**,
  * или **только composite, а source скрывать** (либо по настройке),
  * как помечать составной (например, иконка/тег).

Это не чисто технический, но очень практический момент.

---

## F. Доп. штуки (можно отложить, но полезно иметь в голове)

**13. Удаление / изменение source-тайтлов**

* что происходит, если:

  * удалён один из source → composite должен либо:

    * сам подстраиваться (остается меньше источников),
    * либо помечаться как «битый», если остался без source.
* стоит продумать и в коде, и в UI (простое сообщение «нет доступных источников»).

**14. Тесты / логирование**

* хотя бы минимальные:

  * unit-тест на merge эпизодов из 2–3 провайдеров,
  * тест на то, что фабрика при `is_composite = False` ведёт себя как раньше,
  * логирование: при сборке composite писать в лог список source_ids и итоговое количество эпизодов/streams.

---

### Кратко: чего у тебя не было, но точно стоит добавить

8. Миграция БД (создание таблицы + столбца + default-ы).
9. Правила выбора «основных» метаданных (название/постер и т.п.).
10. Правила отображения composite vs source в списках и поиске.
11. Обработка удаления/изменения source-тайтлов.
12. Минимальные тесты/логирование для merge-логики.

Если хочешь, дальше могу превратить это в прям чек-лист с галочками в стиле `todo.md` + черновой SQLAlchemy-модель `CompositeTitle` и сигнатуры функций `get_source_title_ids`, `merge_episodes_from_titles` и т.д.
